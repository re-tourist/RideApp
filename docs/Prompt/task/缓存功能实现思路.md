# 缓存功能实现思路

下面给你一套**成熟产品常用的“登录态缓存/自动登录”方案**，并明确你们这个仓库（目前 **Compose + ViewModel/Repo + 直连 DB**）要改哪些地方、怎么改。

> 你们当前登录链路是：`Login/Register UI → AuthViewModel → AuthRepository → AuthDatabaseHelper → DatabaseHelper → users 表` ，仓库结构也明确了 `auth/、backend/、navigation/、profile/、ui/screens/` 等目录

------

## 1) 目标体验（对标成熟产品）

1. **一次登录，多次打开不再输密码**：除非用户主动退出/被封禁/缓存过期。
2. **冷启动不卡**：启动先走“本地会话判断”，再异步拉取用户资料；UI 给 Splash / 骨架屏。
3. **安全不存明文密码**：只存“会话凭证”（当前阶段可用 userId + 过期时间；未来接 REST 就换成 token/refreshToken）。
4. **可控**：设置页提供“退出登录”“清除缓存/隐私”入口。

------

## 2) 推荐实现：两阶段（先本地会话，后端上线后平滑升级）

### 阶段 A（你们现在就能落地：直连 DB 的“本地会话”）

因为现在没有后端 token（项目也标注“未开始：Spring Boot REST 后端” ），所以先做**本地 Session**：

**本地缓存内容（最小集）**

- `userId`（必须）
- `loginAt`、`expireAt`（建议 7~30 天）
- `schemaVersion`（以后改结构方便迁移）
- 可选：`nickname/avatarUrl`（用于启动瞬间显示头像昵称，随后再刷新）

**存储方式**

- 优先：`DataStore(Preferences)`（异步、线程安全、比 SharedPreferences 更稳）
- 如果你们想更“成熟”：涉及敏感字段时（未来 token/refreshToken）换成 **EncryptedSharedPreferences**（或 DataStore + 自己加密）。

**启动流程（关键）**

1. App 启动进入 `SplashScreen`（或在 `MainActivity`/`AppNavGraph` 做 gating）。
2. 读取 DataStore：
   - 有 `userId` 且未过期 → 认为已登录，直接进主页
   - 否则 → 去 `LoginScreen`
3. 进主页后，`ProfileRepository` 用 `userId` 拉一次最新用户资料，更新 UI（失败也不影响进入，只是展示旧缓存/默认值）。

这样能显著减少“每次启动都做一次登录校验 + 密码输入”的摩擦，也能减少启动阶段 DB 访问压力（性能更稳）。

### 阶段 B（你们以后上 REST：升级为 token/session，代码不推倒）

你们文档里已经明确要“从直连 DB 迁移到 REST，并做鉴权（JWT/OAuth）” 。届时只要把缓存结构从：

- `userId + expireAt`
  换成：
- `accessToken + refreshToken + expireAt + userId`
  并在网络层加一个拦截器自动带 token、自动 refresh 即可，UI/导航层基本不用改。

------

## 3) 你们项目里具体要改/新增哪些地方（按路径给清单）

### A. 新增：会话缓存组件（建议新建包）

**新建目录**：`app/src/main/java/com/example/rideflow/auth/session/`

新增文件建议：

1. `SessionData.kt`
   - 字段：`userId: Long`, `loginAt: Long`, `expireAt: Long`, `nickname: String?`, `avatarUrl: String?`, `schemaVersion: Int`
2. `SessionStore.kt`
   - 用 DataStore 读写：`saveSession(...)`、`getSessionFlow()`、`clear()`
3. `SessionManager.kt`
   - 业务判断：`isSessionValid(now)`、`requireUserId()`、`logout()`

> 你们社区首页已经用过 SharedPreferences 做首屏缓存 ，所以团队对“本地缓存”不陌生；这次把“登录态”用 DataStore 做成更标准的版本。

------

### B. 改造：AuthRepository / AuthViewModel（登录成功后写入 session）

你们文档列了关键文件：

- `auth/AuthRepository.kt`
- 登录链路包含 `auth/AuthViewModel → auth/AuthRepository`

改动点：

1. `AuthRepository.login(...)` 成功拿到 `userId` 后：
   - `sessionStore.saveSession(userId, expireAt=now+30d, nickname/avatar 可选)`
2. `AuthViewModel`：
   - 增加 `authState`：`CheckingSession / Authed / Unauthed / Error`
   - App 启动时调用 `checkSession()`（从 SessionStore 订阅一次）

------

### C. 改造：导航入口（AppNavGraph / MainActivity 增加“启动判定”）

你们文档点名 `navigation/AppNavGraph.kt` 是高风险文件但最关键 。

改动点（最小可用）：

- 增加一个 `SplashScreen` route（纯 UI：进度/Logo）
- `AppNavGraph` 初始路由设为 Splash
- Splash 内观察 `AuthViewModel.authState`：
  - `Authed` → 导航到主页面（底部导航页）
  - `Unauthed` → 导航到 Login

这样不会在 `LoginScreen` 闪一下又跳走，体验更像成熟 App。

------

### D. 改造：ProfileRepository（用 session 的 userId 作为默认“当前用户”）

你们目前 Profile 相关在 `profile/ProfileRepository.kt`，个人主页在 `ProfileScreen/ProfileDetailScreen/EditProfileScreen` 。

改动点：

- Profile 读“当前用户”时优先从 `SessionManager.requireUserId()` 获取
- 如果 session 失效/用户被禁用（`users.status` 过滤你们已经有 ），就清 session 并跳登录

------

### E. 增加：退出登录（设置页 / 我的页入口）

在“我的/设置”里加一个按钮：

- 点击 → `SessionManager.logout()`（清 DataStore）
- 导航回 Login（并清空 back stack，避免返回键回到已登录页面）

------

## 4) 兼顾性能与体验的细节建议（成熟产品会做）

1. **TTL + 静默刷新**：session 过期前（比如还剩 1 天）启动后后台刷新一次用户资料；失败不打断使用。
2. **异步化**：读取 session 用 Flow/协程，不要阻塞主线程（DataStore 默认就是异步）。
3. **最小缓存**：只缓存“能决定登录态 + 启动瞬间展示”的字段；不要把整份 UserProfile 全量塞进去（后续 schema 变更/脏数据会很痛）。
4. **错误与封禁处理**：你们登录已做 `users.status` 过滤 ；如果发现被封禁/注销：清 session + Toast/弹窗提示。
5. **为后端迁移留口子**：SessionData 里预留 `accessToken/refreshToken` 字段（先不用），将来接 REST 不用重构导航层。

------

## 5) 和你提供的需求文档对齐

你给的需求文档里也明确提到“注册与登录功能”是基础能力之一（用户希望注册后登录使用）；做登录态缓存能直接提升“连续使用/留存”的体验（尤其是你现在吐槽的“每次都要输密码”）。

------

如果你愿意，我可以按你们当前代码风格（Compose + ViewModel + Repository）把**SessionStore/SessionManager 的代码骨架 + AppNavGraph 的跳转伪代码**也写成一份“可直接丢给 code agent 开工”的改动清单（带函数签名和关键逻辑）。