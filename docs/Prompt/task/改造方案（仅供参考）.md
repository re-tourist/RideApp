# 改造方案（仅供参考）

下面是一份**可以直接丢给你的 code agent 开工**的“登录态缓存 / 自动登录”改造方案（含：要新建哪些文件、每个文件写什么、哪些现有文件改哪里、关键 Kotlin 代码骨架）。

> 你们当前链路与目录：`Login/Register UI → auth/AuthViewModel → auth/AuthRepository → backend/AuthDatabaseHelper → backend/DatabaseHelper → users表` ，且 `navigation/AppNavGraph.kt` 属于“危险目录”需要谨慎改动 。另外项目已有“社区首屏 SharedPreferences 缓存”实践 ，这次把“登录态”做成更标准的 DataStore 会话即可。

------

# 0) 目标与约束（实现标准）

- **不再反复输入密码**：有有效会话就自动进主界面。
- **不存明文密码**：缓存“会话信息（userId + expireAt）”，未来接 REST/JWT 平滑升级（你们文档也明确后续要从直连 DB 迁移到 REST，并做 OAuth/JWT 安全整改 ）。
- **启动更快**：启动先走本地会话判断，再异步加载个人资料（减少首屏等待，符合你们“首屏慢”的现状描述 ）。

------

# 1) 新增文件清单（建议新包：auth/session）

在 `app/src/main/java/com/example/rideflow/` 下新增目录：

```
auth/session/
  SessionData.kt
  SessionStore.kt
  SessionManager.kt
  AuthState.kt
```

## 1.1 SessionData.kt

```kotlin
package com.example.rideflow.auth.session

data class SessionData(
    val userId: Long,
    val loginAt: Long,
    val expireAt: Long,
    val nickname: String? = null,
    val avatarUrl: String? = null,
    val schemaVersion: Int = 1
) {
    fun isValid(now: Long): Boolean = userId > 0 && expireAt > now
}
```

## 1.2 AuthState.kt

```kotlin
package com.example.rideflow.auth.session

sealed class AuthState {
    object Checking : AuthState()
    data class Authed(val session: SessionData) : AuthState()
    object Unauthed : AuthState()
    data class Error(val message: String) : AuthState()
}
```

## 1.3 SessionStore.kt（DataStore 读写）

> 你们目前有 SharedPreferences 缓存首屏 ；这里建议用 DataStore（更稳、异步、线程安全）。

先在 `build.gradle(:app)` 加依赖：

```gradle
dependencies {
    implementation "androidx.datastore:datastore-preferences:1.1.1"
}
```

代码骨架：

```kotlin
package com.example.rideflow.auth.session

import android.content.Context
import androidx.datastore.preferences.core.*
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

private val Context.sessionDataStore by preferencesDataStore(name = "session_store")

class SessionStore(private val context: Context) {

    private object Keys {
        val USER_ID = longPreferencesKey("user_id")
        val LOGIN_AT = longPreferencesKey("login_at")
        val EXPIRE_AT = longPreferencesKey("expire_at")
        val NICKNAME = stringPreferencesKey("nickname")
        val AVATAR_URL = stringPreferencesKey("avatar_url")
        val SCHEMA_VERSION = intPreferencesKey("schema_version")
    }

    val sessionFlow: Flow<SessionData?> = context.sessionDataStore.data.map { pref ->
        val userId = pref[Keys.USER_ID] ?: 0L
        val loginAt = pref[Keys.LOGIN_AT] ?: 0L
        val expireAt = pref[Keys.EXPIRE_AT] ?: 0L
        if (userId <= 0L || expireAt <= 0L) return@map null
        SessionData(
            userId = userId,
            loginAt = loginAt,
            expireAt = expireAt,
            nickname = pref[Keys.NICKNAME],
            avatarUrl = pref[Keys.AVATAR_URL],
            schemaVersion = pref[Keys.SCHEMA_VERSION] ?: 1
        )
    }

    suspend fun save(session: SessionData) {
        context.sessionDataStore.edit { pref ->
            pref[Keys.USER_ID] = session.userId
            pref[Keys.LOGIN_AT] = session.loginAt
            pref[Keys.EXPIRE_AT] = session.expireAt
            session.nickname?.let { pref[Keys.NICKNAME] = it } ?: pref.remove(Keys.NICKNAME)
            session.avatarUrl?.let { pref[Keys.AVATAR_URL] = it } ?: pref.remove(Keys.AVATAR_URL)
            pref[Keys.SCHEMA_VERSION] = session.schemaVersion
        }
    }

    suspend fun clear() {
        context.sessionDataStore.edit { it.clear() }
    }
}
```

## 1.4 SessionManager.kt（业务判断 + 便捷方法）

```kotlin
package com.example.rideflow.auth.session

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class SessionManager(
    private val store: SessionStore
) {
    fun authStateFlow(nowProvider: () -> Long): Flow<AuthState> =
        store.sessionFlow.map { s ->
            if (s != null && s.isValid(nowProvider())) AuthState.Authed(s) else AuthState.Unauthed
        }

    suspend fun loginSuccess(userId: Long, ttlDays: Int = 30, nickname: String? = null, avatarUrl: String? = null) {
        val now = System.currentTimeMillis()
        val expireAt = now + ttlDays * 24L * 60 * 60 * 1000
        store.save(SessionData(userId, now, expireAt, nickname, avatarUrl))
    }

    suspend fun logout() = store.clear()
}
```

------

# 2) 需要改动的现有文件（按你们仓库结构对齐）

## 2.1 改：auth/AuthRepository.kt（登录成功后写 session）

你们认证仓库在 `auth/AuthRepository.kt` 。

改造思路：

- `AuthRepository` 构造注入 `SessionManager`
- login/register 成功后调用 `sessionManager.loginSuccess(userId, ...)`

伪代码（你们内部 login 返回结构按实际改）：

```kotlin
class AuthRepository(
    private val authDb: AuthDatabaseHelper,
    private val sessionManager: SessionManager
) {
    suspend fun login(account: String, password: String): Result<Long> {
        val userId: Long = authDb.login(account, password) // 你们现有：邮箱/昵称 + users.status=0 过滤 :contentReference[oaicite:7]{index=7}
        sessionManager.loginSuccess(userId)
        return Result.success(userId)
    }

    suspend fun logout() {
        sessionManager.logout()
    }
}
```

## 2.2 改：auth/AuthViewModel（增加“启动检查会话”与 AuthState）

你们 ViewModel 在 auth 模块下管理状态 。

新增：

- `val authState: StateFlow<AuthState>`
- `fun checkSession()`：订阅 `sessionManager.authStateFlow`

骨架：

```kotlin
class AuthViewModel(
    private val repo: AuthRepository,
    private val sessionManager: SessionManager
) : ViewModel() {

    private val _authState = MutableStateFlow<AuthState>(AuthState.Checking)
    val authState: StateFlow<AuthState> = _authState

    fun checkSession() {
        viewModelScope.launch {
            sessionManager.authStateFlow { System.currentTimeMillis() }
                .collect { _authState.value = it }
        }
    }

    fun login(account: String, password: String) {
        viewModelScope.launch {
            runCatching { repo.login(account, password) }
                .onSuccess { _authState.value = sessionManager.authStateFlow { System.currentTimeMillis() }.first() }
                .onFailure { _authState.value = AuthState.Error(it.message ?: "login failed") }
        }
    }

    fun logout() {
        viewModelScope.launch { repo.logout(); _authState.value = AuthState.Unauthed }
    }
}
```

> 注意：`first()` 只是骨架写法，agent 可以按你们现有状态流风格优化。

------

# 3) 关键：改 navigation/AppNavGraph.kt（加 Splash + 登录态分流）

你们文档明确这个文件“危险、易出问题” ，但必须做“入口分流”。

做法：

1. 新增一个 `SplashScreen`（可以放 `ui/screens/SplashScreen.kt`）
2. App 初始 route 指向 Splash
3. Splash 里观察 `AuthViewModel.authState`：
   - `Authed` → 主界面（底部导航页）
   - `Unauthed` → Login
   - `Checking` → loading
   - `Error` → toast + 去 Login

### 3.1 新增：ui/screens/SplashScreen.kt

```kotlin
@Composable
fun SplashScreen(
    authViewModel: AuthViewModel,
    onGoHome: () -> Unit,
    onGoLogin: () -> Unit
) {
    LaunchedEffect(Unit) { authViewModel.checkSession() }

    val state by authViewModel.authState.collectAsState()

    when (state) {
        is AuthState.Authed -> LaunchedEffect("authed") { onGoHome() }
        is AuthState.Unauthed -> LaunchedEffect("unauthed") { onGoLogin() }
        is AuthState.Checking -> LoadingUi() // 简单圆圈
        is AuthState.Error -> LaunchedEffect("error") { onGoLogin() }
    }
}
```

### 3.2 AppNavGraph.kt 修改点（示意）

- 增加 `SPLASH` route
- startDestination = SPLASH
- onGoHome / onGoLogin 做 `popUpTo` 清栈（成熟产品常用，避免返回键回到 Splash/Login）

------

# 4) “我的/设置”加退出登录（必须）

你们“我的”相关页面在 `ui/screens/ProfileScreen.kt` 等 。加一个“退出登录”按钮，调用 `authViewModel.logout()` 然后导航回 Login，并清栈。

伪代码（放 ProfileScreen 或 SettingsScreen 都行）：

```kotlin
Button(onClick = {
    authViewModel.logout()
    navController.navigate(ROUTE_LOGIN) {
        popUpTo(0) { inclusive = true }
        launchSingleTop = true
    }
}) { Text("退出登录") }
```

------

# 5) ProfileRepository 改成“默认使用当前会话 userId”

你们资料仓库在 `profile/ProfileRepository.kt` 。

改造点：

- 以前可能从页面参数传 userId（或临时写死）
- 现在：如果查“我的资料”，优先从 Session 里取 `userId`

建议做一个方法：

```kotlin
suspend fun loadMyProfile(): UserProfile {
    val userId = sessionStore.sessionFlow.first()?.userId ?: throw IllegalStateException("not logged in")
    return db.queryProfile(userId)
}
```

并且保持你们已有的 `users.status=0` 思路：如果发现用户被禁用/查不到，直接 `sessionManager.logout()` + 导航去 Login（你们登录链路本来就做了 status 过滤 ）。

------

# 6) 最小验收用例（你们文档也建议要有最小测试集 ）

1. 首次启动：无 session → 进入 Login
2. 登录成功：写入 session → 重启 App 直接进主页
3. session 过期：重启 App → 回到 Login
4. 退出登录：清 session → 重启也必须回 Login
5. 用户被禁用（users.status!=0）：下次进入/拉资料时清 session + 回 Login（符合你们 status 过滤逻辑 ）

------

如果你希望我把它进一步“工程化成可复制粘贴的 PR 任务单”，我可以按你们仓库路径（`auth/、profile/、navigation/、ui/screens/` ）列出**逐文件的 TODO 列表 + 需要新增的构造注入点（如 AuthViewModel/Repository 的参数如何接入 Context 的 SessionStore）**，让 agent 直接照着改。